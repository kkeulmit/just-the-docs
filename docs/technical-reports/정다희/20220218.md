---
layout: default
title: 220218_iterator & generator
parent: Technical Report
nav_order: 2
---

#### 1. For...of 루프
- 반복 프토콜을 지원하기 때문에 배열, 문자열, 맵, 세트 등과 같은 내장 객체 및  반복 가능한 사용자 정의 객체에서 사용할 수 있다.
- For...in 루프와 의 차이점은 For...in 루프는 객체의 모든 열거 가능한 속성을 반복한다는 것이다.
- 반면에 For...of 루프는 특정 목적을 가지고 있다.객체가 이터러블 프로토콜을 정의하는 방법에 따라 반복 동작을 수행한다.

#### 2. 이터레이터(반복자)
- next() 메소드 : 두개의 속성을 가진 객체(done, value) 로 컬렉션의 다음 항목을 반환한다.

#### 3. 이터러블
- 반복 동작 또는 내부 반복을 정의하는 객체
- 이터러블 객체의 경우, @@iterator 메소드를 구현해야 한다.
- 객체를 정의 한 후 , [symbol.iterator(){이곳에 Return 값 설정}] 하면 객체를 반복문 돌리면 설정한 return 값이 확인됨.

#### 4. 제너레이터
- 제너레이터 함수는 제너레이트 객체를 반환한다. 
- 제네레이터 함수는 일시중지 됐다가 다시 시작할 수 있다. *제너레이터 함수 자체가 일시 중지를 선택하는 것이고 외부 코드에 의해서는 일시 중지 될 수 없다.
- 함수가 일시 중지되면, 함수 외부의 코드에 의해서만 다시 시작 할 수 있다.
- 필요한 만큼 여러번 일시 중지 했다가 다시 시작할 수 있다. 인기 있는 패턴은 무한 루프를 작성하고 필요할 때 일시중지 했다가 다시 시작하는것.
- 제너레이터 함수가 양방향 메시지 전달을 허용한다. yield 키워드를 사용해 일시중지 할때마다 메시지가 제너레이트 함수에서 전송되고, 함수가 다시 시작되면 제너레이터 함수로 메시지가 다시 전달 된다.
- function 키워드 다음에 *(별표)로 제너레이터 함수임을 나타낼 수 있다.
- yield 키워드를 만나면 함수가 일시 중지된다.
- 제너레이터 객체의 next() 메소드는 함수의 실행을 다시 시작한다.
- 양방향 데이터 전송 : next 메소드 호출하면서 매게 변수를 전달하면 함수 실행이 다시 시작 될 때 yield 에 의해 수신되며 콘솔에 값이 출력된다.

#### 5. 제너레이터 반복
- 제너레이터는 이터레이터이며 이터러블을 지원하는 모든 es6 구조와 마찬가지로 제너레이터를 반복하는데 사용할 수 있다.

#### 6. 컬렉션
- Map, WeakMap, Set, WeakSet 의 네 가지 데이터 구조를 도입했다.
##### 1.  Map : 임의의 값을 keys 로 허용한다. set() 메소드를 통해 키와 연관된 값의 항목을 추가하고 기존 항목을 동일한 키로 겹쳐 쓸 수 있다. get() 은 연관된 값을 가져올 수 있다. .has() : 키가 있는지 검사 .delete() : 삭제 .clear : 전체 맵 삭제
- Map 반복 :Map 은 순서가 중요하다. 요소가 추가된 순서가 유지된다.
- Map 을 반복할때는 keys, values, entries 이렇게 3가지 이터러블을 사용할 수 있다. entries() 메소드는 [키, 값] 쌍의 형식으로 Map 의 항목을 반환한다.

##### 2. Set : 값의 모음이다. 배열과 비슷해 보이지만, 세트는 같은 값을 두 번 허용하지 않는다.
- Set 는 멤버쉽 테스트를 신속하게 수행할 수 있도록 설계 되었다. 배열은 상대적으로 느리다.
- add() has() delete() 메소드 사용 가능
- new Set([...이터레이터 통해 생성 가능])
- 값을 추가 하거나 삭제 할 때, 값이 이미 존재하거나 이미 존재하지 않으면 아무일도 일어나지 않는다.